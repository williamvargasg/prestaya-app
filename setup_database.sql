-- Script completo de inicialización y reparación de base de datos
-- Ejecuta este script en el SQL Editor de Supabase para corregir errores de tablas faltantes

-- 0. Tabla Empresas (Multi-tenant + configuración de multas por mora)
CREATE TABLE IF NOT EXISTS public.empresas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    nombre TEXT NOT NULL,
    dias_mora_para_multa INTEGER NOT NULL DEFAULT 3,
    monto_multa INTEGER NOT NULL DEFAULT 20000,
    config_locked BOOLEAN NOT NULL DEFAULT false,
    config_locked_at TIMESTAMP WITH TIME ZONE
);

-- Insertar empresa por defecto si no existe
INSERT INTO public.empresas (nombre)
SELECT 'Empresa PrestaYa' WHERE NOT EXISTS (SELECT 1 FROM public.empresas);

-- Funciones para obtener empresa y configuración actual
CREATE OR REPLACE FUNCTION public.current_empresa_id()
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE empresa_id BIGINT;
BEGIN
  SELECT p.empresa_id INTO empresa_id
  FROM public.prestamistas p
  WHERE p.user_id = auth.uid()
  LIMIT 1;

  IF empresa_id IS NULL THEN
    SELECT c.empresa_id INTO empresa_id
    FROM public.cobradores c
    WHERE c.user_id = auth.uid()
      AND c.active IS TRUE
    LIMIT 1;
  END IF;

  IF empresa_id IS NULL THEN
    SELECT p.empresa_id INTO empresa_id
    FROM public.prestamistas p
    WHERE lower(p.email) = lower(auth.jwt() ->> 'email')
    LIMIT 1;
  END IF;

  IF empresa_id IS NULL THEN
    SELECT c.empresa_id INTO empresa_id
    FROM public.cobradores c
    WHERE lower(c.email) = lower(auth.jwt() ->> 'email')
      AND c.active IS TRUE
    LIMIT 1;
  END IF;

  RETURN empresa_id;
END;
$$;

CREATE OR REPLACE FUNCTION public.current_empresa_dias_mora_para_multa()
RETURNS INTEGER
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT dias_mora_para_multa
  FROM public.empresas
  WHERE id = public.current_empresa_id()
  LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION public.current_empresa_monto_multa()
RETURNS INTEGER
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT monto_multa
  FROM public.empresas
  WHERE id = public.current_empresa_id()
  LIMIT 1;
$$;

-- Bloqueo de configuración: una vez fijada o con préstamos activos, no se puede modificar
CREATE OR REPLACE FUNCTION public.prevent_empresa_config_update()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE tiene_prestamos BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1 FROM public.prestamos WHERE empresa_id = OLD.id LIMIT 1
  ) INTO tiene_prestamos;

  IF (OLD.config_locked OR tiene_prestamos) AND (
    NEW.dias_mora_para_multa <> OLD.dias_mora_para_multa OR
    NEW.monto_multa <> OLD.monto_multa
  ) THEN
    RAISE EXCEPTION 'La configuración de multas está bloqueada.';
  END IF;

  IF OLD.config_locked AND NEW.config_locked IS FALSE THEN
    RAISE EXCEPTION 'No se permite desbloquear la configuración.';
  END IF;

  IF NEW.config_locked IS TRUE AND OLD.config_locked IS FALSE THEN
    NEW.config_locked_at = timezone('utc'::text, now());
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_empresas_config_lock ON public.empresas;
CREATE TRIGGER trg_empresas_config_lock
BEFORE UPDATE ON public.empresas
FOR EACH ROW
EXECUTE FUNCTION public.prevent_empresa_config_update();

-- Auto-bloquear al crear el primer préstamo si aún no está bloqueado
CREATE OR REPLACE FUNCTION public.lock_empresa_config_on_first_loan()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE public.empresas
  SET config_locked = TRUE,
      config_locked_at = timezone('utc'::text, now())
  WHERE id = NEW.empresa_id
    AND config_locked IS FALSE;
  RETURN NEW;
END;
$$;

DO $$
BEGIN
  IF to_regclass('public.prestamos') IS NOT NULL THEN
    DROP TRIGGER IF EXISTS trg_lock_config_on_first_loan ON public.prestamos;
    CREATE TRIGGER trg_lock_config_on_first_loan
    AFTER INSERT ON public.prestamos
    FOR EACH ROW
    EXECUTE FUNCTION public.lock_empresa_config_on_first_loan();
  END IF;
END;
$$;

-- 1. Tabla Zonas (Requerida por Cobradores)
CREATE TABLE IF NOT EXISTS public.zonas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    nombre TEXT NOT NULL,
    empresa_id BIGINT REFERENCES public.empresas(id)
);

-- Insertar zonas por defecto si no existen
INSERT INTO public.zonas (nombre)
SELECT 'Zona Norte' WHERE NOT EXISTS (SELECT 1 FROM public.zonas);

INSERT INTO public.zonas (nombre)
SELECT 'Zona Sur' WHERE NOT EXISTS (SELECT 1 FROM public.zonas WHERE nombre = 'Zona Sur');

-- 2. Tabla Cobradores
CREATE TABLE IF NOT EXISTS public.cobradores (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    nombre TEXT NOT NULL,
    email TEXT,
    zona_id BIGINT REFERENCES public.zonas(id),
    active BOOLEAN DEFAULT true,
    telefono TEXT,
    user_id UUID REFERENCES auth.users(id),
    empresa_id BIGINT REFERENCES public.empresas(id)
);

-- Asegurar que las columnas existan (por si la tabla ya existía pero incompleta)
ALTER TABLE public.cobradores ADD COLUMN IF NOT EXISTS telefono TEXT;
ALTER TABLE public.cobradores ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id);
ALTER TABLE public.cobradores ADD COLUMN IF NOT EXISTS active BOOLEAN DEFAULT true;
ALTER TABLE public.cobradores ADD COLUMN IF NOT EXISTS zona_id BIGINT REFERENCES public.zonas(id);
ALTER TABLE public.cobradores ADD COLUMN IF NOT EXISTS empresa_id BIGINT REFERENCES public.empresas(id);

-- 3. Tabla Prestamistas (Administradores)
CREATE TABLE IF NOT EXISTS public.prestamistas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    nombre TEXT NOT NULL,
    email TEXT,
    telefono TEXT,
    user_id UUID REFERENCES auth.users(id),
    empresa_id BIGINT REFERENCES public.empresas(id)
);

-- Asegurar columnas en prestamistas
ALTER TABLE public.prestamistas ADD COLUMN IF NOT EXISTS telefono TEXT;
ALTER TABLE public.prestamistas ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id);
ALTER TABLE public.prestamistas ADD COLUMN IF NOT EXISTS empresa_id BIGINT REFERENCES public.empresas(id);

-- Agregar columnas multi-tenant/configuración a tablas existentes
ALTER TABLE IF EXISTS public.zonas ADD COLUMN IF NOT EXISTS empresa_id BIGINT REFERENCES public.empresas(id);
ALTER TABLE IF EXISTS public.deudores ADD COLUMN IF NOT EXISTS empresa_id BIGINT REFERENCES public.empresas(id);
ALTER TABLE IF EXISTS public.prestamos ADD COLUMN IF NOT EXISTS empresa_id BIGINT REFERENCES public.empresas(id);
ALTER TABLE IF EXISTS public.pagos ADD COLUMN IF NOT EXISTS empresa_id BIGINT REFERENCES public.empresas(id);
ALTER TABLE IF EXISTS public.prestamos ADD COLUMN IF NOT EXISTS dias_mora_para_multa INTEGER;
ALTER TABLE IF EXISTS public.prestamos ADD COLUMN IF NOT EXISTS monto_multa INTEGER;

-- Defaults para empresa y configuración de multas
ALTER TABLE IF EXISTS public.zonas ALTER COLUMN empresa_id SET DEFAULT public.current_empresa_id();
ALTER TABLE IF EXISTS public.cobradores ALTER COLUMN empresa_id SET DEFAULT public.current_empresa_id();
ALTER TABLE IF EXISTS public.prestamistas ALTER COLUMN empresa_id SET DEFAULT public.current_empresa_id();
ALTER TABLE IF EXISTS public.deudores ALTER COLUMN empresa_id SET DEFAULT public.current_empresa_id();
ALTER TABLE IF EXISTS public.prestamos ALTER COLUMN empresa_id SET DEFAULT public.current_empresa_id();
ALTER TABLE IF EXISTS public.pagos ALTER COLUMN empresa_id SET DEFAULT public.current_empresa_id();
ALTER TABLE IF EXISTS public.prestamos ALTER COLUMN dias_mora_para_multa SET DEFAULT public.current_empresa_dias_mora_para_multa();
ALTER TABLE IF EXISTS public.prestamos ALTER COLUMN monto_multa SET DEFAULT public.current_empresa_monto_multa();

-- Backfill empresa_id para registros existentes
DO $$
DECLARE empresa_base BIGINT;
BEGIN
  SELECT id INTO empresa_base FROM public.empresas ORDER BY id LIMIT 1;

  IF empresa_base IS NOT NULL THEN
    IF to_regclass('public.zonas') IS NOT NULL THEN
      UPDATE public.zonas SET empresa_id = empresa_base WHERE empresa_id IS NULL;
    END IF;

    IF to_regclass('public.cobradores') IS NOT NULL THEN
      UPDATE public.cobradores SET empresa_id = empresa_base WHERE empresa_id IS NULL;
    END IF;

    IF to_regclass('public.prestamistas') IS NOT NULL THEN
      UPDATE public.prestamistas SET empresa_id = empresa_base WHERE empresa_id IS NULL;
    END IF;

    IF to_regclass('public.deudores') IS NOT NULL THEN
      UPDATE public.deudores SET empresa_id = empresa_base WHERE empresa_id IS NULL;
    END IF;

    IF to_regclass('public.prestamos') IS NOT NULL THEN
      UPDATE public.prestamos
      SET empresa_id = empresa_base,
          dias_mora_para_multa = COALESCE(dias_mora_para_multa, (SELECT dias_mora_para_multa FROM public.empresas WHERE id = empresa_base)),
          monto_multa = COALESCE(monto_multa, (SELECT monto_multa FROM public.empresas WHERE id = empresa_base))
      WHERE empresa_id IS NULL;
    END IF;

    IF to_regclass('public.pagos') IS NOT NULL THEN
      UPDATE public.pagos SET empresa_id = empresa_base WHERE empresa_id IS NULL;
    END IF;
  END IF;
END;
$$;

-- 4. Permisos básicos (necesario si RLS está activo o para roles anon/authenticated)
GRANT ALL ON TABLE public.zonas TO postgres;
GRANT ALL ON TABLE public.zonas TO anon;
GRANT ALL ON TABLE public.zonas TO authenticated;
GRANT ALL ON TABLE public.zonas TO service_role;

GRANT ALL ON TABLE public.cobradores TO postgres;
GRANT ALL ON TABLE public.cobradores TO anon;
GRANT ALL ON TABLE public.cobradores TO authenticated;
GRANT ALL ON TABLE public.cobradores TO service_role;

GRANT ALL ON TABLE public.prestamistas TO postgres;
GRANT ALL ON TABLE public.prestamistas TO anon;
GRANT ALL ON TABLE public.prestamistas TO authenticated;
GRANT ALL ON TABLE public.prestamistas TO service_role;

GRANT ALL ON TABLE public.empresas TO postgres;
GRANT ALL ON TABLE public.empresas TO anon;
GRANT ALL ON TABLE public.empresas TO authenticated;
GRANT ALL ON TABLE public.empresas TO service_role;

-- Activar RLS y políticas multi-tenant
ALTER TABLE IF EXISTS public.empresas ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.zonas ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.cobradores ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.prestamistas ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.deudores ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.prestamos ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.pagos ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS empresas_select ON public.empresas;
CREATE POLICY empresas_select ON public.empresas
FOR SELECT
TO authenticated
USING (id = public.current_empresa_id());

DROP POLICY IF EXISTS empresas_select_anon ON public.empresas;
CREATE POLICY empresas_select_anon ON public.empresas
FOR SELECT
TO anon
USING (true);

DROP POLICY IF EXISTS empresas_update ON public.empresas;
CREATE POLICY empresas_update ON public.empresas
FOR UPDATE
TO authenticated
USING (id = public.current_empresa_id())
WITH CHECK (id = public.current_empresa_id());

DROP POLICY IF EXISTS empresas_insert ON public.empresas;
CREATE POLICY empresas_insert ON public.empresas
FOR INSERT
TO authenticated
WITH CHECK (true);

DROP POLICY IF EXISTS zonas_access ON public.zonas;
CREATE POLICY zonas_access ON public.zonas
FOR ALL
TO authenticated
USING (empresa_id = public.current_empresa_id())
WITH CHECK (empresa_id = public.current_empresa_id());

DROP POLICY IF EXISTS cobradores_access ON public.cobradores;
CREATE POLICY cobradores_access ON public.cobradores
FOR ALL
TO authenticated
USING (
  empresa_id = public.current_empresa_id()
  OR user_id = auth.uid()
  OR lower(email) = lower(auth.jwt() ->> 'email')
)
WITH CHECK (
  empresa_id = public.current_empresa_id()
  OR user_id = auth.uid()
  OR lower(email) = lower(auth.jwt() ->> 'email')
);

DROP POLICY IF EXISTS prestamistas_access ON public.prestamistas;
CREATE POLICY prestamistas_access ON public.prestamistas
FOR ALL
TO authenticated
USING (
  empresa_id = public.current_empresa_id()
  OR user_id = auth.uid()
  OR lower(email) = lower(auth.jwt() ->> 'email')
)
WITH CHECK (
  empresa_id = public.current_empresa_id()
  OR user_id = auth.uid()
  OR lower(email) = lower(auth.jwt() ->> 'email')
);

DO $$
BEGIN
  IF to_regclass('public.deudores') IS NOT NULL THEN
    DROP POLICY IF EXISTS deudores_access ON public.deudores;
    CREATE POLICY deudores_access ON public.deudores
    FOR ALL
    TO authenticated
    USING (empresa_id = public.current_empresa_id())
    WITH CHECK (empresa_id = public.current_empresa_id());
  END IF;

  IF to_regclass('public.prestamos') IS NOT NULL THEN
    DROP POLICY IF EXISTS prestamos_access ON public.prestamos;
    CREATE POLICY prestamos_access ON public.prestamos
    FOR ALL
    TO authenticated
    USING (empresa_id = public.current_empresa_id())
    WITH CHECK (empresa_id = public.current_empresa_id());
  END IF;

  IF to_regclass('public.pagos') IS NOT NULL THEN
    DROP POLICY IF EXISTS pagos_access ON public.pagos;
    CREATE POLICY pagos_access ON public.pagos
    FOR ALL
    TO authenticated
    USING (empresa_id = public.current_empresa_id())
    WITH CHECK (empresa_id = public.current_empresa_id());
  END IF;
END;
$$;

-- 5. Verificar estado final
SELECT 
    table_name, 
    count(*) as columns_count
FROM information_schema.columns 
WHERE table_schema = 'public' 
AND table_name IN ('cobradores', 'prestamistas', 'zonas', 'empresas')
GROUP BY table_name;
